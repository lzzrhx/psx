////////////////////////////////////////////////////////////////////////////////
// This document contains course notes for the course:
// "PS1 Programming with MIPS Assembly & C" by Gustavo Pezzi
// https://pikuma.com/courses/ps1-programming-mips-assembly-language
////////////////////////////////////////////////////////////////////////////////

 SECTIONS:
   #1: COURSE OVERVIEW
   #2: NOTES



  #1 | COURSE OVERVIEW:
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

   [X]  #1: Introduction
   [X]  #2: History & Early Years
   [X]  #3: Playstation Hardware
   [X]  #4: MIPS Assembly
   [X]  #5: Emulation & Debugger
   [X]  #6: The MIPS Pipeline
   [X]  #7: Warm Up Exercises
   [X]  #8: Subroutines & Negative Numbers
   [X]  #9: CISC vs RISC
   [X] #10: Graphics System
   [X] #11: Rendering Polygons
   [X] #12: Memory Alignment
   [X] #13: Copying Data to VRAM
   [X] #14: Moving from Assembly to C
   [X] #15: Psy-Q Data Types
   [X] #16: Introduction to 3D Graphics
   [X] #17: The GTE Coprocessor
   [X] #18: Fixed-Point Math
   [X] #19: GTE Inline Instructions
   [X] #20: Controller Input
   [-] #21: Linking Multiple Files
   [-] #22: Camera Transformation
   [-] #23: CD-ROM Access
   [-] #24: Textured Polygons
   [-] #25: Decoding Primitive Files
   [-] #26: Decoding Texture Files
   [-] #28: Multiple 3D Models
   [-] #29: Loading Landscape Objects
   [-] #30: Loading Track Faces
   [-] #31: Loading Track Texture
   [-] #32: Polygon Subdivision
   [-] #33: Movement & Physics
   [-] #34: Refactoring Track Visibility
   [-] #35: Attracting & Track
   [-] #36: Audio
   [-] #37: Conclusion

   [X] COMPLETED / [-] NOT COMPLETED



  #2 | NOTES
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
   - Links:
     Playstation Specifications: https://psx-spx.consoledev.net/
   - Course pipeline:
     + History of the development of the Playstation
     + Hardware and technical specs
     + Star with: MIPS assembly
     + Then move on to: C compiler & the Psy-Q library
     + Topics:
       + Graphics
         + Ordering tables
         + GPU instructions
         + GTE
       + Audio
       + Joypad input
       + Gaming programming patterns
         + Fixed-point math
     + At the end of the course we'll put everything we've learned together and create a game

   - Toolchain:
     + The original Psy-Q 32-bit library requires Windows 95 or XP
     + But a modern 64-bit Psy-Q wrapper is also available for Windows 11
   
   - Timeline:
     + 1978: (8-bit  / 2nd gen) Atari 2600 released, started the revolution of home consoles with cartridges
     + 1985: (8-bit  / 3rd gen) Famicom / NES released
     + 1989: (16-bit / 4th gen) Sega Megadrive / Genesis
     + 1991: (16-bit / 4th gen) Super Famicom / SNES
     + 1992: 3D arcade games (Virtua Fighter, Virtua Racing, etc.)
     + 1993: (32-bit / 5th gen) Panasonic 3DO
     + 1993: (32-bit / 5th gen) Atari Jaguar
     + 1994: (32-bit / 5th gen) Sega Saturn
     + 1994: (32-bit / 5th gen) Sony Playstation

   - 5th generation consoles:
     + 32-bit
     + CD-ROM
     + 3D polygon graphics

   - Ken Kutaragi is known as "the father of the Playstation"

   - Technical specs:
     + CPU: 32-bit R3000A MIPS(LSI) at 33.86 MHz
     + RAM: 2MB EDO Memory
     + VRAM: 1MB
     + GPU: SCPH-9000 chip responsible for rasterization
     + Coprocessors:
       + CP0: System Control
       + CP2: GTE (Geometry Transformation Engine)
       + MDEC (Motion Decoder)
     + SPU: Sound Processing Unit (16-bit 24-channel ADPCPM)
     + CD Subsystem: DSP controlling the motor & laser

   - The PS1 MIPS (Microprocessor without Interlocked Pipelined Stages) CPU:
     + Sony commissioned LSI Logic to build their CPU. The LSI CW33300 block was binary-compatible with the MIPS R3000A and used the same instruction set
     + Sony CXD8530BQ (System on a Chip)
     + R3000A from MIPS & LSI Logic
     + 32-bit RISC architecture
       + RISC: Reduced Instruction Set Computer is designed for efficient execution by a pipelined processor and for code generation by an optimizing compiler
     + CPU specs:
       + 32 general-purpose registers
       + 2 multiplication and division registers
       + 32-bit data bus
       + 32-bit address bus
       + 1 ALU (arithmetic logic unit)
       + 5-stage pipeline
     + Coprocessors:
       + CP0: System Control (cache, interrupts, exceptions, etc.)
       + CP2: GTE (3D transformations and matrix math)
       + MDEC: Media Decoder (full motion video)

   - ISA (Instruction Set Architecture):
     + Is a specification that describes the aspects of the CPU that are visible to a machine language programmer or to an assembler
     + MIPS is one example of ISA, other examples are: x86, RISC-V, ARM, SPARC, PowerPC

   - Endianness (byte ordering):
     + The R3000A MIPS CPU of the PS1 uses Little Endian
     + With Little Endian the least-significant byte of the number is placed first
     + Example number: 0x12345678
       + Big Endian:    12 34 56 78
       + Little Endian: 78 56 34 12
     
   - CPU Memory Map:
      KUSEG           KSEG0 (cached)  KSEG1 (uncached)
      0x00000000      0x80000000      0xA0000000        2048K    Main RAM (first 64K reserved for BIOS)
      0x1F000000      0x9F000000      0xBF000000        8192K    Expansion Region 1 (ROM/RAM)
      0x1F800000      0x9F800000      ---               1K       Scratchpad (D-Cache used as Fast RAM)
      0x1F801000      0x9F801000      0xBF801000        4K       I/0 Ports
      0x1F802000      0x9F802000      0xBF802000        8K       Expansion Region 2 (I/O Ports)
      0x1FA00000      0x9FA00000      0xBFA00000        2048K    Expansion Region 3 (general purpose)
      0x1FC00000      0x9FC00000      0xBFC00000        512K     BIOS ROM (Kernel)

     + Kernel Memory (upper 2GB):
       + KSEG1: is the normal physical memory (cache disabled)
       + KSEG0: is a mirror of KSEG1 (with cache enabled)

     + User Memory (lower 2GB):
       + KUSEG: Only the first 512MB of KUSEG are addressable
         + In most MIPS processors, KUSEG is intended to contain 2GB of virtual memory.
           The PSX doesn't support virtual memory, so KUSEG simply contains a mirror of KSEG0/KSEG1 in the first 512MB.

   - Examples of I/O Ports at 0x1F80----
     + GPU registers:
       + 0x1F801810 - write - GP0: Send GP0 commands/packets (rendering & VRAM access)
       + 0x1F801814 - write - GP1: Send GP1 commands/packets (display control)
       + 0x1F801810 - read  - GPUREAD: Read responses to GP0 (C0h) and GP1 (10h) commands
       + 0x1F801814 - read  - GPUSTAT: Read GPU status register
     + SPU control registers:
       + 0x1F801D80 - Main volume left/right
       + 0x1F801D84 - Reverb output colume left/right
       + 0x1F801D88 - Voice 0..23 Key ON  (start attack/decay/sustain)
       + 0x1F801D8C - Voice 0..23 Key OFF (start release)
     + MDEC registers:
       + 0x1F801820 - write - MDEC command/parameter register
       + 0x1F801824 - write - MDEC control/reset register
       + 0x1F801820 - read  - MDEC data/response register
       + 0x1F801824 - read  - MDEC status register

   - MIPS Registers
     r0  = $zero
     r1  = $at
     r2  = $v0
     r3  = $v1
     r4  = $a0
     r5  = $a1
     r6  = $a2
     r7  = $a3
     r8  = $t0
     r9  = $t1
     r10 = $t2
     r11 = $t3
     r12 = $t4
     r13 = $t5
     r14 = $t6
     r15 = $t7
     r16 = $s0
     r17 = $s1
     r18 = $s2
     r19 = $s3
     r20 = $s4
     r21 = $s5
     r22 = $s6
     r23 = $s7
     r24 = $t8
     r25 = $t9
     r26 = $k0
     r27 = $k1
     r28 = $gp
     r29 = $sp
     r30 = $fp
     r31 = $ra

   - Load instructions
     + Load immediate:
       li $t0,10
       li $t0,0xFE
     + Load address:
       la $t2,Label
     + Load byte (load one byte from address with offset):
       lb $t3,0x8000($t0)
     + Load byte (insigned):
       lbu $t3,0x8000($t0)
     + Load upper immediate:
       lui $t4,0x8001
     + Load half:
       lh ...
     + Load word:
       lw ...
   
   - Size of MIPS Types
     + BYTE, 1 byte, 8 bits
     + HALF, 2 bytes, 16 bits
     + WORD, 4 bytes, 32 bits
     + DWORD, 8 bytes, 64 bits

   - Size of relevant C types
     + char, 1 byte, 8 bits
     + short, 2 bytes, 16 bits
     + int, 4 bytes, 32 bits
     + long, 4 bytes, 32 bits
     + long long, 8 bytes, 64 bits

  - Store instructions
    + Store word (store one word with offset):
      sw $t1,0x1810($t0)
    + Store half-word:
      sh ...
    + Store byte:
      sb ...

  - Add & subtract instructions
    + add $t0, $t1, $t2  // t0 = t1 + t2
    + sub $a0, $a0, $a2  // a0 = a0 - a2
    + addi $t0, $t1, 5   // t0 = t1 + 5
    + addi $s0, $s1, -5  // s0 = s1 - 5
    + addu $s0, $s1, $s1 // s0 = s1 + s1 (unsigned)
    + addiu $s0, $s1, 7  // s0 = s1 + 7 (unsigned)

  - Jump instructions
    + Unconditional jump:
      j Label
      nop
    + Jump to register:
      jr $a3
      nop
    + Jump and link:
      jal SubroutineName
      nop


  - Branch instructions
    + Branch if equals:
      beq $t0, $t1, Label
      nop
    + Branch if not equals:
      bne $t0, $t1, Label
      nop
    + Branch if less than (signed / unsigned):
      blt ... / bltu ...
      nop
    + Branch if grater than (signed / unsigned):
      bgt ... / bgtu ...
      nop
    + Branch if less or equals (signed / unsigned):
      ble ... / bleu ...
      nop
    + Branch of greater or equals (signed / unsigned):
      bge ... / bgeu ...
      nop

  - ARMIPS (assembler): https://github.com/Kingcom/armips

  - PCSX-Redux (ps1 emulator): https://github.com/grumpycoders/pcsx-redux

  - bin2exe.py (.bin to-ps-exe converter): https://github.com/ARM9/psxdev/blob/master/libpsx/tools/bin2exe.py

  - Make for Windows: https://gnuwin32.sourceforge.net/packages/make.htm

  - Running a program:
    1. armips program.s
    2. python bin2exe.py program.bin program.ps-exe
    3. load program.ps-exe in pcsx-redux

  - Loading a program in PCSX-Redux and running it step by step:
    + Debug -> Show Logs
    + Debug -> CPU -> Show Registers
    + Debug -> CPU -> Show Assembly
    + Debug -> CPU -> Memory Editors -> Memory Editor #1
    + Assembly -> Enable Debugger
    + Configuration -> Emulation -> Disable Dynarec CPU

  - MIPS Pipeline
    + Fetch -> Decode -> Execute -> Memory -> Write
    + While a typical instruction takes 3-5 cycles, a pipelined processor targets 1 cycle per instruction
    + But this pipeline approach can cause some problems when branching
    + Or when performing operations on a register right after a load from memory
    + These problems can be solved by adding delay slots (nop)

  - Sign Extension (8-bit to 16 -bit example)
    + If the number is positive:
                          0 0 1 1 1 0 0 1
      ->  0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1
    + If the number is negative (two's complement):
                          1 0 1 1 1 0 0 1
      ->  1 1 1 1 1 1 1 1 1 0 1 1 1 0 0 1

  - 512x1024 frame buffer (VRAM)
  - GP0 used to send packets to the GPU
    + Packets (command + paramters):
      Command + color    CCBBGGRR
      Vertex 1           YYYYXXXX
      Vertex 2           YYYYXXXX
      Vertex 3           YYYYXXXX
      Vertex 4 (if quad) YYYYXXXX
  - GP1 used to send control parameters to the GPU
    + Command + params: CCPPPPPP

  - Psy-Q was the original SDK and can be used to program for the PS1 with the C programming language

  - There are other community-driven SDKs:
    + PSn00bSDK - https://github.com/Lameguy64/PSn00bSDK
    + CandyK-PSX - https://github.com/ChenThread/candyk-psx
    + CKSDK - https://github.com/cuckydev/CKSDK
    + PSXSDK - https://unhaut.epizy.com/psxsdk/?i=2

  - Install instructions for Windows 11:
    + VS Code: https://code.visualstudio.com/
      + Extensions -> PSX.Dev, install
      + Extensions -> Native Debug & clangd
      + ctrl+shift+p -> PSX.Dev, show panel -> templates: Psy-Q SDK (Psy-Q Cube (install recommended tools)) -> reboot -> create
      + to build: ctrl+shift+p -> PSX.Dev build debug
      + to run: ctrl+shift+p -> launch PSXC-Redux

  - Install instructions for Windows XP:
    + Install VirtualBox -> Add Windows XP (4GB RAM/20GB HDD)
    + Install Mypal web browser (https://www.mypal-browser.org/)
    + Install Programmer's Notepad 2.4.2.1440 (simple editor)
    + Install Code::Blocks 8.02 (IDE)
    + psxdev.net: (https://web.archive.org/web/20250418044622/https://www.psxdev.net/downloads.html)
      + Download PSY-Q SDK (https://drive.google.com/file/d/0B_GAaDjR83rLZGVaZ2pvV2tjSVE/view?resourcekey=0-KKkvWLASG3gmlP3jNqZskQ)
      + Download Programmers Tool CD 2.2 (https://drive.google.com/file/d/0B_GAaDjR83rLOGp3aTYzc0haVGs/view?resourcekey=0-uyLemqoC68cNjP5w6dYeQg)
    + Install no$psx v2.2 Windows 32bit version (http://problemkaputt.de/no$psx.zip)
    + Extract PSY-Q to C:\psyq
    + Control Panel -> Classic View -> System -> Advanced -> Environment Variables. Add:
      + PATH -> ... ;C:\psyq\bin
      + PSX_PATH -> C:\psyq\bin
      + LIBRARY_PATH -> C:\psyq\lib
      + C_INCLUDE_PATH -> C:\psyq\include
      + PSYQ_PATH -> C:\psyq\bin
      + COMPILER_PATH -> C:\psyq\bin
      + GO32 -> DPMISTACK 1000000
      + GO32TMP -> C:\WINDOWS\TEMP
      + TMP -> C:\WINDOWS\TEMP
  
  - PSY-Q tools:
    + ccpsx - Compiler
    + psymake - Make for PSY-Q

  - 3D Transformations (using the GTE):
    + When we start the vertices are in model space (local coordinate system)
    + Then, we transform the vertices into world space (multiply by the world matrix)
    + The next step is to convert the vertices into camera space (multiply by view matrix)
    + The scene is now in view space and can be projected into screen space (perspective divide)

  - The PS1 doesn't have native support for floating point numbers and the GTE usues 20.12 fixed-point numbers:
    + 20.12 fixed-point bits: SIIIIIIIIIIIIIIIIIIIFFFFFFFFFFFF
                               \              \              \
                                Sign bit    Integer bits    Fractional bits
    + Integer to 20.12 fixed-point number: 2^12 = 4096 = 1.0
    + #define ONE 4096
    + Fractional addition and subtraction:
      + fix_num += 4096;   // += 1.0
      + fix_num -= 4096;   // -= 1.0
      + fix_num += 2048;   // += 0.5
      + fix_num -= 6144;   // -= 1.5
      + long a = 20 * ONE; // ToFixed(20)
      + long b = 17 * ONE; // ToFixed(17)
      + long c = a + b;    // Addition "just works"
    + Fractional multiplication:
      + mul = 2048;                      // mul = 0.5
      + fix_num = (fix_num * mul) >> 12; // fix_num *= mul
      + mul = 6144;                      // mul = 1.5
      + fix_num = (fix_num * mul) >> 12; // fix_num *= mul
    + Fractional division:
      + div = 2048;                       // div = 0.5
      + fix_num = (fix_num * 4096) / div; // fix_num /= div
      + div = 6144;                       // div = 1.5
      + fix_num = (fix_num * 4096) / div; // fix_num /= div
    + Bitshifting can also be used to perform multiplication and division if multiplying/dividing by 2/4/8/etc.